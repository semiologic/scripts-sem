#!/bin/bash
#
# Author: Denis de Bernardy <http://www.mesoconcepts.com>
# Version: 0.2
# Copyright Mesoconcepts, All Rights Reserved
#


#
# Initialize
#

if [[ "$HOME" == "/Users/denis" ]]; then
	readonly debug=1
	readonly svn_root=file:///var/svn
	readonly dbn=api
else
	readonly debug=0
	readonly svn_root=https://svn.semiologic.com
	readonly dbn=semiologic
fi


readonly cwd=`pwd`
readonly dir="/tmp/`uuidgen`"

mkdir $dir && cd $dir || exit 1
trap "cd $cwd; rm -Rf $dir" EXIT


#
# sem_exec()
#

function sem_exec() {
	if [[ "$1" = '-v' ]]; then
		readonly v='' && shift
		
		local cmd=$1 && shift
	else
		local cmd=$1 && shift
		
		if [[ "$1" = '-v' ]]; then
			readonly v='' && shift
		else
			readonly v='-q'
		fi
	fi

	if [[ "$cmd" == 'help' ]]; then
		sem_help $* && return 0
	elif [[ $# -lt 1 ]]; then
		echo 'Err: Insufficient number of arguments. Type sem help.' && return 1
	fi
	
	# parse details
	eval "`sem_parse $1`" && shift
	
	# validate package
	svn list $svn_root/$svn &> /dev/null
	
	if [[ $? -ne 0 ]]; then
		if [[ "$type" != '' ]]; then
			echo "Err: Failed to lookup $svn_root/$svn" && return 1
		fi
		
		for type in plugins themes skins lib bail; do
			if [[ $type = 'bail' ]]; then
				echo "Err: Failed to locate $svn in $svn_root" && return 1
			else
				svn list $svn_root/$type/$svn &> /dev/null && svn=$type/$svn && break
			fi
		done
	fi
	
	case $cmd in
		parse )
			echo $svn || return 1
			;;
		
		info )
			eval "`sem_info $svn $*`" && echo $version || return 1
			;;
		
		deps )
			sem_deps $svn $* || return 1
			;;
		
		check )
			sem_check $svn $* || return 1
			;;
		
		tag )
			sem_tag $svn $* || return 1
			;;
		
		zip )
			sem_pub stable $svn $* || return 1
			;;
		
		dev )
			sem_pub bleeding $svn $* || return 1
			;;
		
		* )
			echo 'Err: Invalid Command. Type sem help.' && return 1
			;;
	esac
	
	return 0
}


#
# sem_help()
# ----------
# Output help
#

function sem_help() {
	echo 'Usage:'
	echo
	echo '  sem help command: help on command'
	echo '  sem parse package: outputs the package'"'"'s svn info'
	echo '  sem info package: outputs the package'"'"'s version'
	echo '  sem deps package: output a packages'"'"' depends'
	echo '  sem check package: ok if a package is publishable'
	echo '  sem tag package [version]: tag a package'
	echo '  sem zip package [version]: publish a stable zip'
	echo '  sem dev package [version]: publish a bleeding edge zip'
	
	return 0
}


#
# sem_parse()
#

function sem_parse() {
	local svn=$1
	local package
	local type
	local branch
	local rev
	
	svn=${svn##/}
	svn=${svn%%/}
	
	if [[ "$svn" =~ @ ]]; then
		rev=@${svn##*@}
		svn=${svn%%@*}
		svn=${svn%%/}
	fi
	
	if [[ ! "$svn" =~ (.+)/(trunk|(branches/[^/]+|tags/[^/]+))$ ]]; then
		package=$svn
		branch=trunk
	else
		package=${BASH_REMATCH[1]}
		branch=${BASH_REMATCH[2]}
	fi
	
	if [[ "$package" =~ ^([^/]+)/([^/]+)$ ]]; then
		type=${BASH_REMATCH[1]}
		package=${BASH_REMATCH[2]}
	elif [[ ! "$package" =~ ^[^/]+$ ]]; then
		echo "Err: invalid package ($package)" && return 1
	fi
	
	svn=$package/$branch$rev
	
	if [[ "$type" != '' ]]; then
		svn=$type/$svn
	fi
	
	echo "local svn='$svn'"
	echo "local type='$type'"
	echo "local package='$package'"
	echo "local branch='$branch'"
	echo "local rev='$rev'"
	
	return 0
}


#
# sem_info()
#

function sem_info() {
	# catch version if passed as an argument
	if [[ $# > 1 ]]; then
		shift && echo "local version='$*'" && return 0
	fi
	
	eval "`sem_parse $1`"
	
	local hash=`md5 -q -s "$svn"`
	
	if [[ -f $hash.info ]]; then
		echo "local version='`cat $hash.info`'" && return 0
	fi
	
	local version
	local file
	
	case $type in
		plugins | lib )
			file=$package.php
			;;
		
		themes )
			file=style.css
			;;
		
		skins )
			file=skin.css
			;;
		
		* )
			if [[ "$package" = 'sem-pro' ]]; then
				file='wp-includes/version.php'
			else
				echo "Err: Unsupported package type ($svn)" && return 1
			fi
			;;
			
	esac
	
	svn cat $svn_root/$svn/$file > $hash.info || exit 1
	
	if [[ "$package" = 'sem-pro' ]]; then
		version=`tail -n 20 $hash.info | grep -i -m 1 -E '\\$sem_pro_version[[:space:]]*='`
		version=${version%"'"*}
		version=${version##*"'"}
	else
		version=`head -n 10 $hash.info | grep -i -m 1 -E 'Version[[:space:]]*:.+'`
		version=${version##*:}
		version=${version##[[:space:]]}

		version=${version/(fork)/}
		version=${version/fork/}

		version=${version%%[[:space:]]}
	fi
	
	echo $version > $hash.info
	
	echo "local version='`cat $hash.info`'"
	
	return 0
}


#
# sem_deps()
#

function sem_deps() {
	local svn=$1
	local hash=`md5 -q -s "$svn"`
	
	if [[ ! -f $hash.deps ]]; then
		svn pg svn:externals $svn_root/$svn > $hash.deps.bak
		cat $hash.deps.bak \
		| sed -E '/^$/d' \
		> $hash.deps;
	fi
	
	cat $hash.deps \
	| sed -E 's/\^\/(.+)/\1/g' \
	| sed -E 's/[[:space:]].*//g' \
	| sed -E 's/\/$//g'
	
	return 0
}


#
# sem_check()
#

function sem_check() {
	local dep
	
	for dep in $1 `sem_deps $1`; do
		eval "`sem_parse $dep`"
		
		if [[ "$svn" =~ /trunk$ ]]; then
			eval "`sem_info $svn`"
			
			if [[ $version =~ [1-9] && $version =~ ^[0-9]*(\.[0-9]+)*$ ]]; then
				if [[ "$svn" = "$1" ]]; then
					continue
				else
					sem_check $svn && continue || return 1
				fi
			else
				echo $dep $version
				return 1
			fi
		fi
	done
	
	return 0
}


#
# sem_tag()
#

function sem_tag() {
	eval "`sem_parse $*`"
	sem_check $svn
	
	if [[ $? -ne 0 ]]; then
		eval "`sem_info $*`" && echo "Err: Failed to tag $package v.$version" && return 1
	fi
	
	local dep
	local hash=`md5 -q -s "$svn"`
	
	for dep in `sem_deps $svn`; do
		eval "`sem_parse $dep`"
		
		if [[ "$svn" =~ /(trunk|branches/[^/]+)$ ]]; then
			eval "`sem_info $svn`"
			sem_tag $svn
			
			if [[ $? -ne 0 ]]; then
				echo "Err: Failed to tag $package v.$version" && return 1
			else
				if [[ -s $hash.deps ]]; then
					if [[ "$type" = '' ]]; then
						sed -i '' -E "s|\^/$svn/?|^/$package/tags/$version/|g" $hash.deps
					else
						sed -i '' -E "s|\^/$svn/?|^/$type/$package/tags/$version/|g" $hash.deps
					fi
				fi
			fi
		fi
	done
	
	eval "`sem_parse $*`"
	eval "`sem_info $*`"
	
	local svn_tag=$package/tags/$version
	
	if [[ "$type" != '' ]]; then
		svn_tag=$type/$svn_tag
	fi
	
	svn list $svn_root/$svn_tag &> /dev/null
	
	if [[ $? -ne 0 ]]; then
		echo -n "Tagging $package v.$version"
		
		if [[ -s $hash.deps ]]; then
			svn $v --depth=empty co $svn_root/$svn $hash.branch \
			&& svn $v ps svn:externals -F $hash.deps $hash.branch \
			&& svn $v ci -m "Freeze $package v.$version" $hash.branch \
			|| return 1
		fi
		
		svn cp $svn_root/$svn $svn_root/$svn_tag -m "Tag $package v.$version" || return 1
		
		if [[ -s $hash.deps ]]; then
			svn $v ps svn:externals -F $hash.deps.bak $hash.branch \
			&& svn $v ci -m "Unfreeze $package v.$version" $hash.branch || return 1
		fi
	fi
	
	return 0
}


#
# sem_pub()
#

function sem_pub() {
	local method=$1 && shift
	
	eval "`sem_parse $*`"
	
	if [[ "$method" = 'stable' ]]; then
		sem_check $svn > /dev/null && sem_tag $svn
	fi
	
	local dep
	
	for dep in `sem_deps $svn`; do
		sem_check $dep > /dev/null
		
		if [[ $? -eq 0 ]]; then
			sem_pub stable $dep || return 1
		else
			sem_pub bleeding $dep || return 1
		fi
	done
	
	local hash=`md5 -q -s "$svn"`
	local zip=`svn pg sem:zip $svn_root/$svn`
	local updated=0
	
	local path=$zip
	local file=${zip##*/}
	local assets
	
	touch $hash.readme
	
	if [[ "$zip" != '' ]]; then
		eval "`sem_info $*`"
		if [[ $debug -ne 0 ]]; then
			path=~/Desktop/media
		else
			path=${path##*://}
			path=${path#www.}
			path=${path%/*}
			
			local domain=${path%%/*}
			
			path=/usr/local/www/$domain/www/${path#*/}
		fi
		
		if [[ "$method" = 'bleeding' ]]; then
			file=${file%.zip}-dev.zip
		fi
		
		svn $v export $svn_root/$svn $package \
		&& zip $v -r $file $package || return 1
		
		if [[ "$type" != '' && -f $package/readme.txt ]]; then
			cp $package/readme.txt $hash.readme
		fi
		
		rm -Rf $package || return 1
		
		if [[ ! -f $path/$file || ! `diff -q $file $path/$file &> /dev/null` ]]; then
			echo "Publishing $file v.$version"
			
			mkdir -p $path \
			&& mv $file $path/$file \
			&& updated=1 \
			|| return 1
		fi
		
		if [[ "$type" = 'skins' ]]; then
			svn $v export $svn_root/$type/$package/assets $package-assets \
			&& zip $v -r $package-assets.zip $package-assets \
			&& cp $package-assets/screenshot.jpg $package-screenshot.jpg \
			|| return 1
			
			rm -Rf $package-assets || return 1
			
			for file in $package-assets.zip $package-screenshot.jpg; do
				if [[ ! -f $path/$file || ! `diff -q $file $path/$file &> /dev/null` ]]; then
					echo "Publishing $file v.$version"
					
					mkdir -p $path \
					&& mv $file $path/$file || return 1
				fi
			done
		fi
	fi
	
	if [[ $updated -ne 0 && "$zip" != '' ]]; then
		local stable_zip=$zip
		local bleeding_zip=${zip%.zip}-dev.zip
		
		local ext=`svn pg sem:ext $svn_root/$svn`

		if [[ "$ext" != '' ]]; then
			if [[ "$method" = 'stable' ]]; then
				sem_ext $* || return 1
			fi
			
			case $type in
				'plugins' )
					stable_zip=http://downloads.wordpress.org/plugin/$package.zip
					;;
			esac
		fi
		
		if [[ "$type" = '' ]]; then
			type=core
		fi
		
		local url=$zip
		local requires
		local compat
		
		if [[ -s $hash.readme ]]; then
			requires=`grep -i -E 'Requires[[:space:]]+at[[:space:]]+least[[:space:]]*:' $hash.readme`
			compat=`grep -i -E 'Tested[[:space:]]+up[[:space:]]+to[[:space:]]*:' $hash.readme`
			
			requires=${requires##*:}
			requires=${requires##[[:space:]]}
			requires=${requires%%[[:space:]]}
			
			compat=${compat##*:}
			compat=${compat##[[:space:]]}
			compat=${compat%%[[:space:]]}
		fi
		
		url=${url%/*}/
		url=${url/media\//}
		
		local check="SELECT EXISTS ( SELECT 1 FROM packages WHERE type = '$type' AND package = '$package' )"
		
		if [[ 1 -eq `mysql -u root $dbn -sN -e "$check"` ]]; then
			if [[ "$method" = 'stable' ]]; then
				zip=$stable_zip
			else
				zip=$bleeding_zip
			fi
			
			mysql -u root $dbn -t <<SQL

UPDATE	packages
SET		url = '$url',
		${method}_package = '$zip',
		${method}_version = '$version',
		${method}_requires = '$requires',
		${method}_compat = '$compat',
		${method}_modified = NOW(),
		${method}_readme = load_file('$dir/$hash.readme')
WHERE	type = '$type'
AND		package = '$package';

SQL
			if [[ $? -ne 0 ]]; then
				return 1
			fi
		else
			local hash=`md5 -q -s "$svn"`
			local stable_version
			local bleeding_version
			
			local stable_requires
			local bleeding_requires
			
			local stable_compat
			local bleeding_compat
			
			if [[ "$method" = 'stable' ]]; then
				stable_version=$version
				stable_requires=$requires
				stable_compat=$compat
				stable_readme="load_file('$dir/$hash.readme')"
				bleeding_readme="''"
			else
				bleeding_version=$version
				bleeding_requires=$requires
				bleeding_compat=$compat
				stable_readme="''"
				bleeding_readme="load_file('$dir/$hash.readme')"
			fi
			
			mysql -u root $dbn -t <<SQL
			#cat <<SQL

INSERT INTO packages (
		type,
		package,
		url,
		stable_version,
		stable_package,
		stable_requires,
		stable_compat,
		stable_modified,
		bleeding_version,
		bleeding_package,
		bleeding_requires,
		bleeding_compat,
		bleeding_modified,
		stable_readme,
		bleeding_readme
		)
VALUES (
		'$type',
		'$package',
		'$url',
		'$stable_version',
		'$stable_zip',
		'$stable_requires',
		'$stable_compat',
		NOW(),
		'$bleeding_version',
		'$bleeding_zip',
		'$bleeding_requires',
		'$bleeding_compat',
		NOW(),
		$stable_readme,
		$bleeding_readme
		);

SQL
			if [[ $? -ne 0 ]]; then
				return 1
			fi
			
			if [[ "$method" = 'bleeding' ]]; then
				sem_pub stable $* || return 1
			fi			
		fi
		
		if [[ "$method" = 'stable' ]]; then
			sem_pub bleeding $* || return 1
		fi
	fi
	
	return 0
}


#
# sem_ext()
#

function sem_ext() {
	eval "`sem_parse $*`"
	
	sem_check $svn > /dev/null || return 0
	
	local ext=`svn pg sem:ext $svn_root/$svn`
	
	if [[ "$ext" = '' ]]; then
		return 0
	fi
	
	if [[ $debug -ne 0 && ! -d ~/Desktop/$package ]]; then
		return 0
	fi
	
	eval "`sem_info $*`"
	
	local svn_tag=$package/tags/$version
	
	if [[ "$type" != '' ]]; then
		svn_tag=$type/$svn_tag
	fi
	
	if [[ $debug -ne 0 ]]; then
		cp -R ~/Desktop/$package $package.ext || return 1
	else
		svn $v export $ext $package.ext || return 1
	fi
	
	svn $v rm $package.ext/* \
	&& svn $v export $svn_root/$svn_tag $package.ext --force \
	&& svn $v add $package.ext/* \
	&& svn $v ps svn:eol-style native -R $package.ext \
	|| return 1
	
	if [[ "`svn diff $package.ext`" != '' ]]; then
		echo "Merging $package v.$version"
		
		if [[ $debug -eq 0 ]]; then
			svn $v ci $package.ext -m "$package v.$version" || return 1
		fi
	fi
	
	rm -Rf $package.ext || return 1
	
	return 0
}


#
# execute
#

sem_exec $* && exit 0 || exit 1